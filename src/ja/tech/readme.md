# WebGAL 技術紹介

## シーンシステムとプリロード

### シーン取得

WebGAL のシーンはファイル単位で、一般的には拡張子が`.txt`のWebGAL スクリプトファイルです。多くのプログラミング言語にエントリとしての `main`関数があるように、WebGAL のエントリシーンは`start.txt`です。WebGAL はまず `start.txt`を取得し、WebGAL パーサーを呼び出してスクリプトファイルを WebGAL エンジンが実行できるシーンオブジェクトに解析します。どのシーンでも、`choose`、`changeScene`、`callScene`などの方法でシーンを切り替えたり「呼び出したり」することができます。シーンを切り替えると現在のシーンが直接置き換えられ、「呼び出された」シーンはシーン呼び出しスタックに新しいシーンをプッシュして実行を開始し、実行後にそのシーンを呼び出した親シーンに戻ります。

### シーン内のリソースをプリロードする

WebGAL がシーンを解析するのと同時に、シーンに含まれるリソースも解析されます。各シーンファイルについて、WebGAL は画像、オーディオ、ビデオファイルなど、含まれるすべてのリソースを解析します。これらのファイルはシーンの解析が完了した後にプリロードを開始し、ユーザーがゲームプレイ中にリソースのロードを待つ可能性をできるだけ減らします。同時に、ゲームのシーン切り替えをよりスムーズにするために、WebGAL は現在のシーンファイルで参照されているシーンファイルのリソースもロードします。リソースの無駄を避けるため、WebGAL はプリロードするシーンを 1 層だけ拡張します。

## WebGAL パーサー

### ステートメント解析 Ⅰ シーンを分割する

WebGAL シーンファイルは主に改行によってスクリプトを区別します。解析の最初に、WebGAL パーサーは改行文字に従ってスクリプトを分割します。セミコロンがある場合は、セミコロンより前の文字を取得します。そのため、WebGAL スクリプトのコメント方法は、コメントをセミコロンの後に書くことです。

### ステートメント解析 Ⅱ スクリプトタイプの解析

WebGAL のスクリプトは一般に次の形式です。

```
command:content -arg1 -arg2 ......;comment
```

ここで、command は `bgm`、`changeFigure`、`choose`などのステートメント命令を表し、ステートメントに対応する制御アクションを示します。`content`はステートメントの主要な内容を表します。たとえば、`bgm:Teabreak.mp3`は、BGM としてオーディオファイルの一部を再生することを意味します。

### ステートメント解析 Ⅲ 会話の特殊処理

WebGAL の会話は一般的に次のように記述されます。

```
森川由绮:胸につかえていることを、时は解决してくれない。忘却のラベルを贴るだけで -voice_1.ogg;
```

ビジュアルノベルの場合、会話は一般にスクリプトの主要な構成要素であるため、WebGAL は構文糖を設計しました。スクリプトの command 部分がどの命令にも解析できない場合、WebGAL はそれを会話とみなします。音声はファイル名だけを指定すればパラメータを簡略化することもできます。上記の会話は最終的には `say` 命令として解析されます。

したがって、この会話の真の表現は次のようになります。

```
say:胸につかえていることを、时は解决してくれない。忘却のラベルを贴るだけで -speaker=森川由绮 vocal=voice_1.ogg;
```

それ以外に、会話が 1 人のキャラクターによって発せられる場合、会話の相手が変わるまでは、キャラクター名を省略することもできます。

```
森川由绮:胸につかえていることを;
时は解决してくれない;
忘却のラベルを贴るだけで;
```

会話の特殊処理により、スクリプト記述の効率が大幅に向上します。

### ステートメント解析 Ⅳ パラメータ解析

content の後に `-` で区切られた追加パラメータがあります。特に注意すべき点は、追加パラメータのハイフン `-` の前にはスペースが必要であることです。そうしないと、WebGAL はこれがパラメータではなく通常のハイフンであるとみなす可能性があります。

WebGAL のパラメータは `-key=value` の形式で表されます。ここで、`key` の型は `string` であり、`value` の型は動的に決定でき、以下の 3 つの可能な型が存在します。`string`、`number`、`boolean`。

たとえば、`-key=s` の `value` は `string` です。`-key=1` の `value` は `number` であり、`-key=true` または `-key=false` の `value` は `boolean` です。

そのうち、`key` のみを出力して `value` を省略したパラメータは `-key=true` として解析されます。これは簡略化された構文糖です。この構文糖は非常に重要です。なぜなら、WebGAL には `-next` という重要なパラメータがあり、これは現在のステートメントの実行が完了したらすぐに次のステートメントを実行することを意味するからです。省略表示がない場合、毎回 `-next=true` を記述する必要があります。

### ステートメント解析 Ⅴ リソース処理とプリロード

ステートメント解析を実行すると、ステートメントに必要なリソースを取得できます。たとえば、`bgm` ステートメントには通常オーディオ リソースが必要であり、`playVideo` ステートメントには通常ビデオ リソースが必要であり、`changeBg` ステートメントには通常画像リソースが必要です。WebGAL シーン パーサーは、すべてのシーンでステートメントに必要なリソースを結合して、プリローダーに渡してリソースをプリロードします。同時に、`changeScene`、`choose`、`callScene` など、子シーンを呼び出す必要がある状況が発生すると、子シーンもスキャンされ、解析され、その中のリソースがプリロードされます。

## フロー制御システム

### 準備段階: ステップ前操作

フロー制御モジュールは、シーン命令ストレージ モジュール (このモジュールはシーン管理モジュールのサブ モジュールです) から命令を取得し、ステップ前操作と検査を実行します。ステップ前操作には、主に前のフローで終了していないアニメーション、ビデオなどの持続時間のある視覚効果を停止することが含まれます。この操作は、ユーザーが前のフローが持続時間に達して正常に終了する前にマウスをクリックするか、指定のショートカット キーを押すと、ユーザーがこのフローが持続時間に達するまで待機したくない可能性があり、このフローをスキップしたいと考える可能性があるためです。このとき、フロー制御システムは対応するフローを提前終了する関数を呼び出します (各視覚効果には、その効果をアンロードするために使用される関数を提供する必要があります。この関数を呼び出すと、その視覚効果が完全にアンロードされます)。検査には、スキップできない視覚効果があるかどうかと、現在のシーンの最後のステートメントに到達したかどうかを確認することが含まれます。スキップできない視覚効果が存在する場合 (一部の視覚効果スクリプトは特殊なためスキップできず、記事の管理者が設定します)、ユーザーは持続時間に達するまで待ってから次のフローに進むことができます。現在のシーンの最後のステートメントに到達した場合、フロー制御モジュールはシーン呼び出しスタックが空かどうかを確認します。空でない場合は、スタックの一番上の要素 (シーン オブジェクト) を現在のシーン ストレージ モジュールに格納されているシーンに置き換え、「現在のステートメント」のポインターをシーンの最初のステートメントに向け、その後このステートメントを実行します。シーン呼び出しスタックが空の場合、インタラクティブな読書フローは終了したと見なすことができ、このときエンジンはインタラクティブな読書のメイン インターフェイスに戻ります。

### 正式段階 Ⅰ: 命令を読み取り、条件判定を実行する

この段階では、命令が読み取られ、条件判定が行われます。各命令には実行条件を記述するパラメータ (when パラメータ) が含まれる可能性があるため、命令を実行するたびに条件判定を行う必要があります。このとき、フロー制御モジュールは実行条件を記述するパラメータを変数と条件判定モジュールに送り、条件判定を要求します。条件判定モジュールは条件判定式を解析し、エンジンの内部変数と組み合わせて条件判定を行い、最終的に条件判定結果 (真または偽) を返します。フロー制御モジュールはこの結果に基づいて、この命令を実行するかどうかを判断します。実行しない場合、その後のすべての手順をスキップし、準備段階に戻って次の命令を読み取ります。

条件判定が真の結果を返した場合、フロー制御モジュールは正式段階 II に入ります。

### 正式段階 Ⅱ: 呼び出し、演出制御モジュールを取得して演出コントローラーに送信する

この段階では、ステートメントの命令を実行するアクションを正式に実行します。各タイプの命令は 1 つのアクションに対応し、このアクションは命令構成と実行モジュールに格納されます。命令構成と実行モジュールには、命令に対応するアクションの構成が格納されています。アクションの構成には、命令が実行する必要がある状態変更操作 (たとえば、「ステージ」の背景を変更したり、特定の位置のキャラクター画像を切り替えたりすること)、アニメーションや特殊効果操作 (たとえば、背景やキャラクター画像にアニメーション効果を追加したり、雨や雪の特殊効果を開始したりすること)、マルチメディア リソースの再生などが含まれます。この構成は命令実行器に送信され、命令実行器によって対応するアクションが具体的に実行されます。各命令実行器は指定のアクションを実行した後、「演出制御モジュール」を返します。ここで「演出」とは、持続時間のある視覚効果のことです。「演出制御モジュール」は、現在の実行中の視覚効果の説明情報と、その視覚効果をアンロードするために使用される関数を記述します。この関数は、視覚効果が持続時間に達した後、またはユーザーが事前に命令を出して中断した後、自動的に呼び出されます。このモジュールは「演出コントローラー」に送信されます。このコントローラーは「演出制御モジュール」を維持する責任を負い、持続時間に達した後に「演出」を自動的にアンロードしたり、ユーザー操作後に準備段階にあるフロー コントローラーが呼び出されて「演出」を提前終了したりするメソッドが含まれます。

### 終了段階: 連続演出の処理、バックログの更新

命令の実行が終了すると、終了段階に入ります。この段階では、主に読書履歴の記録を維持します。読書の過程でユーザーの読書履歴を記録する必要があるため、ユーザーはいつでも自分の読書履歴を確認し、特定の記録ノードに戻ることができます。従来の紙の本や図文混在の読書方法では、ユーザーは通常、ページを戻したり、マウス ホイールを上にスクロールしたりして、以前に読んだ位置に戻ります。インタラクティブな読書では、読書の流れがユーザーの操作によって変化する可能性があるため、従来の記録方法 (ページ番号やスクロール位置などを記録する) を使用することはできません。そのため、終了段階のたびに、フロー制御モジュールは現在の読書位置 (通常は特定のシーンの第 n 番目の命令) と現在の変数情報とシーン状態情報を記録します。このように、ユーザーが過去に読んだ特定の記録ノードに戻りたい場合、以前に読んだ位置を簡単に読み取って復元できます。

### 自動と早送り

自動読書と早送りシステムは、本質的には指定された間隔内でユーザーに代わってステップを実行しようとするものです。自動と早送りの主な違いは、送信される命令の優先度と間隔が異なることです。

自動モードでは、一定時間ごとに (自動モードで設定された速度によって異なります)、フロー制御システムに「ステップ」を実行するよう命令が出されます。自動モードの優先度は低いため、自動演出をブロックする演出 (ビデオ再生、会話、アニメーションなど、ほとんどの演出は自動モードをブロックする演出です) がある場合は、演出のブロックが解除されるまで実行されません。

早送りモードでは、ほとんどの演出はスキップされ、選択肢のようにユーザーが何らかの操作を実行する必要がある演出のみがスキップされません。早送りモードのトリガー間隔も明らかに短くなっています。

## 演出制御

### WebGAL 演出タイプ

### 演出的自動破棄、終了判定、ブロックロジック

## ステージコントローラーとアニメーション制御

### データ駆動型 Pixi ステージコントローラー

### アニメーションと「変換」制御

### データ駆動型フィルター マネージャー

## セーブ/ロード、巻き戻し、ユーザー データ

### WebGAL ステージ状態表の紹介

### 演出状態の保存と復元

### アーカイブとその他のユーザー データの保存

## 鑑賞モジュールとその他の細部

### 鑑賞モジュール

### ブラウザ状態の維持と「ゲームの続行」

### ショートカット キーとマウス操作