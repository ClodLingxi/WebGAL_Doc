# 上級スクリプト

## ステートメントジャンプと選択肢ジャンプ(同じTXTファイル内)

分岐を作成したいが、新しい TXT ファイルを作成するのが面倒だと感じた場合は、以下を読んでみてください。

**注意:分岐が非常に長い場合は、1 つの TXT の行数が長すぎてはいけないため、この方法を使用することはお勧めしません。**

### まず、ラベルを作成する

```
......
jumpLabel:label_1; 
; // 次の行は無視される。
...... 
......
......
; // 次に、ラベルを作成する。
label:label_1;
ゲームはここで継続して実行されます。;
......
......
```

つまり、`jumpLabel` は `goto` ステートメントに似ており、スクリプトをシーン内の任意の位置(TXT ファイル)にすぐにジャンプさせることができ、この位置は ラベルを使用して作成する必要があります。

`jumpLabel` を任意のゲートと比較すると、この任意のゲートの終点はラベルが配置されている位置になります。

### 次に、選択肢を作成する

choose コマンドを使用して選択肢を作成することができます。オプションを選択して、対応するラベルの位置にジャンプします。

```
WebGAL: 選択肢ジャンプをテストしましょう！;
choose:テスト 1:label_1|テスト 2:label_2;
label:label_1;  
ここは分岐 1 です。;
jumpLabel:end;
label:label_2;
ここは分岐 2 です。;
jumpLabel:end; 
label:end;
分岐はここで統一されます;
```

各分岐の最後に、`jumpLabel` を使用して目的の場所にジャンプする必要があることに注意してください。ゲームは直線的に実行されるため、分岐の最後にジャンプしないと、ゲームは次のように継続して実行されます。

```
WebGAL: 選択肢ジャンプをテストしましょう！;
choose:テスト 1:label_1|テスト 2:label_2;  
label:label_1;
ここは分岐 1 です。;
label:label_2;
ここは分岐 2 です。;
分岐はここで統一されます;
```

このスクリプトでは、テスト 2 を選択すると、すべて問題ないように見えます。ただし、テスト 1 を選択すると、テスト 1 の実行後にテスト 2 が実行されることに驚かれることでしょう。これは、ゲームが順番に継続して実行され、分岐の終了後にジャンプするラベルを指定しなかったためです。

## 変数の使用

**注意: ラベルの作成と選択肢ジャンプを理解する前に、混乱を招く可能性があるため、変数を軽々しく使用しないでください。**

変数を設定します。

```
setVar:a=1; // 数値の設定が可能
setVar:a=true // ブール値の設定が可能
setVar:a=Character name // 文字列の設定が可能
```

以前に変数を設定した場合でも、変数を設定するときに再利用できます。

## 条件付き実行

ステートメントの後に `-when=(condition)` を追加することで、条件に基づいて現在のステートメントを実行するかどうかを決定します。

例:

```
setVar:a=1;
changeScene:1.txt -when=a>1; // a > 1 の場合、シーン 1 にジャンプする
changeScene:2.txt -when=a==1; // a が 1 の場合にのみジャンプし、等価演算子は == であることに注意してください
changeScene:3.txt; // a < 1 の場合, 上記のステートメントは実行されないので、当然これは実行される
```

**注意: `=` は代入記号であり、条件付き実行には使用できません。`==` は等値演算子です。**

`-when` パラメータを任意のステートメントに追加して、実行するかどうかを制御できます。`-when` パラメータと `jumpLabel` `callScene` `changeScene` を組み合わせることで、条件付き実行による実行制御を実現できます。

## 会話文に効果を追加する

キャラクターが話している間に表情などを切り替えたい場合があります。
`-notend` と `-concat` パラメータを使用して、会話に任意のステートメントを挿入することができます。

`-concat` は、このセリフは前のセリフの後につながっていることを意味します。

`-notend` は、このセリフはまだ終わっておらず、後で効果やセリフがつながることを意味します。

例: 会話の進行中に立ち絵と表情を切り替える。

```
WebGAL: 会話の進行中に立ち絵の切り替えをテストしてみましょう!今すぐに...... -notend;
changeFigure:k1.png -next;
立ち絵の切り替えが成功しました！表情の切り替えをテストしてみましょう...... -notend -concat; 
changeFigure:k2.png -next;
表情の切り替えも成功しました！ -concat;
```

## カスタム特殊効果の追加

ソースコードをダウンロードし、`/Core/gameScripts/pixiPerformScripts` に移動し、カスタム特殊効果のために `PIXI.Container` を作成します。

```ts
const effectsContainer = RUNTIME_GAMEPLAY.pixiStage!.effectsContainer!; // 現在の Pixi.Container の特殊効果を取得する
const app = RUNTIME_GAMEPLAY.pixiStage!.currentApp!; // Pixi アプリのインターフェースを呼び出すと、画面サイズなどの確認に役立つ場合があります
const container = new PIXI.Container(); // カスタム特殊効果のコンテナを作成する
effectsContainer.addChild(container); // カスタム特殊効果を追加する
```

テクスチャファイルは `/game/tex` フォルダーに配置する必要があります。

次に、ファイルの先頭でカスタム特殊効果の登録メソッドを導入します。

ファイルの末尾で、登録メソッドを使用して、カスタム特殊効果を登録します。最初のパラメータは特殊効果名で、2 番目のパラメータは特殊効果を呼び出すメソッドです。

```typescript
import {registerPerform} from '../pixiPerformManager';

// 特殊効果の定義
function myPerform(parameters) {
  // ...
}

// 登録
registerPerform('myPerform', () => myPerform(parameters)); 
```

最後に、カスタム特殊効果をサポートする WebAPP をコンパイルします

```shell
yarn run build;
```

これで、スクリプトでカスタム特殊効果を呼び出すことができます。

```
pixiPerform:myPerform; // 特殊効果名を指定して特殊効果を呼び出す
```
